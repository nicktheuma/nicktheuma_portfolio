import { existsSync, mkdirSync, readdirSync, readFileSync, statSync, writeFileSync } from 'node:fs'
import path from 'node:path'
import { exiftool } from 'exiftool-vendored'
import sharp from 'sharp'
import heicConvert from 'heic-convert'
import { GetObjectCommand, ListObjectsV2Command, S3Client } from '@aws-sdk/client-s3'

const projectRoot = process.cwd()
const mediaProjectsRoot = path.join(projectRoot, 'public', 'media', 'projects')
const outputFile = path.join(projectRoot, 'src', 'content', 'generated-projects.ts')

function loadEnvFile(filePath) {
  if (!existsSync(filePath)) {
    return
  }

  const lines = readFileSync(filePath, 'utf8').split(/\r?\n/)
  for (const line of lines) {
    const trimmed = line.trim()
    if (!trimmed || trimmed.startsWith('#')) {
      continue
    }

    const equalsIndex = trimmed.indexOf('=')
    if (equalsIndex < 1) {
      continue
    }

    const key = trimmed.slice(0, equalsIndex).trim()
    const value = trimmed.slice(equalsIndex + 1).trim()
    if (!key || process.env[key] !== undefined) {
      continue
    }

    process.env[key] = value
  }
}

loadEnvFile(path.join(projectRoot, '.env'))
loadEnvFile(path.join(projectRoot, '.env.local'))

const imageExtensions = new Set(['.jpg', '.jpeg', '.png', '.webp', '.avif', '.gif', '.heic', '.heif'])
const videoExtensions = new Set(['.mp4', '.webm', '.mov', '.m4v'])
const modelExtensions = new Set(['.glb', '.gltf', '.stl', '.obj', '.fbx'])
const heicExtensions = new Set(['.heic', '.heif'])

const skippedFolderNames = new Set(['archive', '.generated'])
const finalPriorityFolderNames = new Set(['final'])
const processPriorityFolderNames = new Set(['process', 'working'])

const manifestSource = (process.env.R2_MANIFEST_SOURCE ?? 'auto').trim().toLowerCase()
let activeManifestSource = 'local'
const requiredR2EnvVars = ['R2_ACCOUNT_ID', 'R2_ACCESS_KEY_ID', 'R2_SECRET_ACCESS_KEY', 'R2_BUCKET_NAME']
const missingR2EnvVars = requiredR2EnvVars.filter((name) => typeof process.env[name] !== 'string' || process.env[name].trim().length === 0)
const hasR2Credentials = missingR2EnvVars.length === 0
const r2BucketPrefix = (process.env.R2_BUCKET_PREFIX ?? 'media').trim().replace(/^\/+|\/+$/g, '')

function buildR2ProjectsPrefix() {
  return [r2BucketPrefix, 'projects'].filter(Boolean).join('/') + '/'
}

function shouldUseR2Source() {
  if (manifestSource === 'r2') {
    return true
  }

  if (manifestSource === 'local') {
    return false
  }

  return hasR2Credentials
}

function createR2Client() {
  const accountId = process.env.R2_ACCOUNT_ID?.trim()
  const accessKeyId = process.env.R2_ACCESS_KEY_ID?.trim()
  const secretAccessKey = process.env.R2_SECRET_ACCESS_KEY?.trim()

  if (!accountId || !accessKeyId || !secretAccessKey) {
    throw new Error('R2 credentials are not configured. Set R2_ACCOUNT_ID, R2_ACCESS_KEY_ID, and R2_SECRET_ACCESS_KEY.')
  }

  return new S3Client({
    region: 'auto',
    endpoint: `https://${accountId}.r2.cloudflarestorage.com`,
    credentials: {
      accessKeyId,
      secretAccessKey,
    },
  })
}

function normalizeMediaPath(value) {
  if (!value) {
    return ''
  }

  return toPosixPath(value).replace(/^\/+/, '')
}

function mediaPathFromObjectKey(objectKey) {
  const normalizedKey = normalizeMediaPath(objectKey)

  if (!normalizedKey) {
    return ''
  }

  if (r2BucketPrefix && normalizedKey.startsWith(`${r2BucketPrefix}/`)) {
    return `/media/${normalizedKey.slice(r2BucketPrefix.length + 1)}`
  }

  return `/media/${normalizedKey}`
}

function objectKeyFromMediaPath(mediaPath) {
  const normalizedPath = normalizeMediaPath(mediaPath).replace(/^media\//, '')
  if (!normalizedPath) {
    return ''
  }

  return r2BucketPrefix ? `${r2BucketPrefix}/${normalizedPath}` : normalizedPath
}

function fileNameWithoutExtensionPosix(filePath) {
  return path.posix.basename(filePath, path.posix.extname(filePath))
}

async function generateThumbnailDataUrl(sourceBuffer) {
  try {
    // Create a small, blurred thumbnail: 40x40px, heavily blurred for instant load
    const thumbBuffer = await sharp(sourceBuffer)
      .resize(40, 40, { fit: 'cover' })
      .blur(8)
      .jpeg({ quality: 30 })
      .toBuffer()
    
    const base64 = thumbBuffer.toString('base64')
    return `data:image/jpeg;base64,${base64}`
  } catch (error) {
    // If thumbnail generation fails, return empty string (no placeholder)
    return ''
  }
}

// Video thumbnails are generated by reusing the first available image thumbnail
// from the same project. This avoids expensive ffmpeg processing during builds.

function folderPriorityForObjectKey(objectKey, projectSlug) {
  const projectPrefix = `${buildR2ProjectsPrefix()}${projectSlug}/`
  const normalizedKey = normalizeMediaPath(objectKey)

  if (!normalizedKey.startsWith(projectPrefix)) {
    return 2
  }

  const relativePath = normalizedKey.slice(projectPrefix.length)
  const dirSegments = path.posix
    .dirname(relativePath)
    .split('/')
    .map((segment) => segment.toLowerCase())
    .filter(Boolean)

  if (dirSegments.some((segment) => finalPriorityFolderNames.has(segment))) {
    return 0
  }

  if (dirSegments.some((segment) => processPriorityFolderNames.has(segment))) {
    return 1
  }

  return 2
}

function compareRemoteObjectKeys(leftKey, rightKey, projectSlug) {
  const leftPriority = folderPriorityForObjectKey(leftKey, projectSlug)
  const rightPriority = folderPriorityForObjectKey(rightKey, projectSlug)

  if (leftPriority !== rightPriority) {
    return leftPriority - rightPriority
  }

  return normalizeMediaPath(leftKey).localeCompare(normalizeMediaPath(rightKey))
}

function shouldSkipRemotePathForManifest(relativePath) {
  return relativePath
    .split('/')
    .map((segment) => segment.toLowerCase())
    .some((segment) => skippedFolderNames.has(segment))
}

function shouldApplyMonochromeForObject(objectKey, projectSlug) {
  return folderPriorityForObjectKey(objectKey, projectSlug) === 1
}

async function listAllR2Objects(s3, bucket, prefix) {
  const objects = []
  let continuationToken = undefined

  do {
    const response = await s3.send(
      new ListObjectsV2Command({
        Bucket: bucket,
        Prefix: prefix,
        ContinuationToken: continuationToken,
      }),
    )

    objects.push(...(response.Contents ?? []))
    continuationToken = response.IsTruncated ? response.NextContinuationToken : undefined
  } while (continuationToken)

  return objects
}

async function readR2Json(s3, bucket, key) {
  try {
    const response = await s3.send(
      new GetObjectCommand({
        Bucket: bucket,
        Key: key,
      }),
    )

    const body = await response.Body?.transformToString?.()
    if (!body) {
      return {}
    }

    const parsed = JSON.parse(body)
    return parsed && typeof parsed === 'object' ? parsed : {}
  } catch {
    return {}
  }
}

async function buildProjectsFromR2() {
  const bucket = process.env.R2_BUCKET_NAME?.trim()
  if (!bucket) {
    throw new Error('R2_BUCKET_NAME is required for R2 manifest generation.')
  }

  const s3 = createR2Client()
  const projectsPrefix = buildR2ProjectsPrefix()
  const objects = await listAllR2Objects(s3, bucket, projectsPrefix)

  if (objects.length === 0) {
    if (existsSync(outputFile)) {
      console.warn(`Skipping R2 media manifest generation: no objects found for r2://${bucket}/${projectsPrefix}. Keeping existing ${toPosixPath(path.relative(projectRoot, outputFile))}.`)
      return null
    }
  }

  const projectSlugs = new Set()
  const imageKeysBySlug = new Map()
  const videoKeysBySlug = new Map()
  const modelKeysBySlug = new Map()
  const lastModifiedByKey = new Map()

  for (const object of objects) {
    const objectKey = object.Key ? normalizeMediaPath(object.Key) : ''
    if (!objectKey || objectKey.endsWith('/')) {
      continue
    }

    if (!objectKey.startsWith(projectsPrefix)) {
      continue
    }

    if (object.LastModified) {
      lastModifiedByKey.set(objectKey, new Date(object.LastModified))
    }

    const relativeToProjects = objectKey.slice(projectsPrefix.length)
    const [slug, ...rest] = relativeToProjects.split('/')
    if (!slug || rest.length === 0) {
      continue
    }

    const relativePath = rest.join('/')
    if (relativePath === 'project.json' || shouldSkipRemotePathForManifest(relativePath)) {
      projectSlugs.add(slug)
      continue
    }

    const extension = path.posix.extname(relativePath).toLowerCase()
    projectSlugs.add(slug)

    if (imageExtensions.has(extension)) {
      imageKeysBySlug.set(slug, [...(imageKeysBySlug.get(slug) ?? []), objectKey])
      continue
    }

    if (videoExtensions.has(extension)) {
      videoKeysBySlug.set(slug, [...(videoKeysBySlug.get(slug) ?? []), objectKey])
      continue
    }

    if (modelExtensions.has(extension)) {
      modelKeysBySlug.set(slug, [...(modelKeysBySlug.get(slug) ?? []), objectKey])
    }
  }

  const sortedSlugs = [...projectSlugs].sort((left, right) => left.localeCompare(right))
  const projects = await Promise.all(
    sortedSlugs.map(async (slug) => {
      const metaKey = `${projectsPrefix}${slug}/project.json`
      const meta = await readR2Json(s3, bucket, metaKey)
      const counters = {}

      const imageKeys = [...(imageKeysBySlug.get(slug) ?? [])].sort((left, right) => {
        const leftDate = lastModifiedByKey.get(left)
        const rightDate = lastModifiedByKey.get(right)
        if (leftDate && rightDate) {
          return rightDate - leftDate // Most recent first
        }
        return compareRemoteObjectKeys(left, right, slug)
      })
      const videoKeys = [...(videoKeysBySlug.get(slug) ?? [])].sort((left, right) => {
        const leftDate = lastModifiedByKey.get(left)
        const rightDate = lastModifiedByKey.get(right)
        if (leftDate && rightDate) {
          return rightDate - leftDate // Most recent first
        }
        return compareRemoteObjectKeys(left, right, slug)
      })
      const modelKeys = [...(modelKeysBySlug.get(slug) ?? [])].sort((left, right) => compareRemoteObjectKeys(left, right, slug))

      const images = await Promise.all(
        imageKeys.map(async (objectKey, index) => {
          const rawFilename = fileNameWithoutExtensionPosix(objectKey)
          const autoType = isAutoGeneratedFilename(rawFilename, 'image')

          let title
          if (autoType === 'recording') {
            counters.recording = (counters.recording || 0) + 1
            title = `rec_${counters.recording}`
          } else if (autoType === 'whatsapp') {
            counters.whatsapp = (counters.whatsapp || 0) + 1
            title = `chat_${counters.whatsapp}`
          } else if (autoType === 'archive') {
            counters.archive = (counters.archive || 0) + 1
            title = `archive_${counters.archive}`
          } else {
            title = rawFilename || `image_${index + 1}`
          }

          // Generate thumbnail from R2 object
          let thumbnail = ''
          try {
            const imageResponse = await s3.send(
              new GetObjectCommand({
                Bucket: bucket,
                Key: objectKey,
              }),
            )
            const imageBuffer = await imageResponse.Body?.transformToByteArray?.()
            if (imageBuffer) {
              thumbnail = await generateThumbnailDataUrl(imageBuffer)
            }
          } catch (error) {
            // Silently fail thumbnail generation
          }

          return {
            title,
            location: null,
            captureDate: lastModifiedByKey.get(objectKey) ?? null,
            src: mediaPathFromObjectKey(objectKey),
            thumbnail: thumbnail || undefined,
            monochrome: shouldApplyMonochromeForObject(objectKey, slug),
          }
        }),
      )

      // Get shared thumbnail for videos from first image
      const sharedVideoThumbnail = images[0]?.thumbnail || ''

      const videos = videoKeys.map((objectKey, index) => {
        const rawFilename = fileNameWithoutExtensionPosix(objectKey)
        const autoType = isAutoGeneratedFilename(rawFilename, 'video')

        let title
        if (autoType === 'recording') {
          counters.recording = (counters.recording || 0) + 1
          title = `rec_${counters.recording}`
        } else if (autoType === 'whatsapp') {
          counters.whatsapp = (counters.whatsapp || 0) + 1
          title = `chat_${counters.whatsapp}`
        } else if (autoType === 'archive') {
          counters.archive = (counters.archive || 0) + 1
          title = `archive_${counters.archive}`
        } else if (autoType === 'video') {
          counters.video = (counters.video || 0) + 1
          title = `video_${counters.video}`
        } else {
          title = rawFilename || `video_${index + 1}`
        }

        return {
          title,
          location: null,
          captureDate: lastModifiedByKey.get(objectKey) ?? null,
          src: mediaPathFromObjectKey(objectKey),
          thumbnail: sharedVideoThumbnail || undefined,
          monochrome: shouldApplyMonochromeForObject(objectKey, slug),
        }
      })

      const models = modelKeys.map((objectKey, index) => {
        const rawFilename = fileNameWithoutExtensionPosix(objectKey)
        const autoType = isAutoGeneratedFilename(rawFilename, 'model')

        let title
        if (autoType === 'recording') {
          counters.recording = (counters.recording || 0) + 1
          title = `rec_${counters.recording}`
        } else if (autoType === 'whatsapp') {
          counters.whatsapp = (counters.whatsapp || 0) + 1
          title = `chat_${counters.whatsapp}`
        } else if (autoType === 'archive') {
          counters.archive = (counters.archive || 0) + 1
          title = `archive_${counters.archive}`
        } else if (autoType === 'model') {
          counters.model = (counters.model || 0) + 1
          title = `model_${counters.model}`
        } else {
          title = rawFilename || `model_${index + 1}`
        }

        return {
          title,
          location: null,
          previewSrc: images[index]?.src ?? images[0]?.src ?? '',
          fileSrc: mediaPathFromObjectKey(objectKey),
          monochrome: shouldApplyMonochromeForObject(objectKey, slug),
        }
      })

      const thumbnailSrc =
        typeof meta.thumbnailSrc === 'string' && meta.thumbnailSrc.length > 0
          ? meta.thumbnailSrc
          : videos[0]?.src ?? images[0]?.src ?? ''

      const thumbnailObjectKey = objectKeyFromMediaPath(thumbnailSrc)

      return {
        slug,
        title: typeof meta.title === 'string' && meta.title.length > 0 ? meta.title : slugToTitle(slug),
        categoryId: typeof meta.categoryId === 'string' ? meta.categoryId : 'renders',
        tagIds: Array.isArray(meta.tagIds) ? meta.tagIds.filter((value) => typeof value === 'string') : [],
        summary: typeof meta.summary === 'string' ? meta.summary : '',
        thumbnailSrc,
        thumbnailMonochrome:
          typeof meta.thumbnailMonochrome === 'boolean'
            ? meta.thumbnailMonochrome
            : shouldApplyMonochromeForObject(thumbnailObjectKey, slug),
        body: Array.isArray(meta.body) ? meta.body.filter((value) => typeof value === 'string') : [],
        images,
        videos,
        models,
      }
    }),
  )

  return projects.filter((project) => project.thumbnailSrc || project.images.length || project.videos.length || project.models.length)
}

function toPosixPath(value) {
  return value.replaceAll(path.sep, '/')
}

function slugToTitle(slug) {
  return slug
    .split('-')
    .filter(Boolean)
    .map((part) => part.charAt(0).toUpperCase() + part.slice(1))
    .join(' ')
}

function safeReadProjectMeta(projectFolderPath) {
  const metaPath = path.join(projectFolderPath, 'project.json')
  if (!existsSync(metaPath)) {
    return {}
  }

  try {
    const text = readFileSync(metaPath, 'utf8')
    return JSON.parse(text)
  } catch {
    return {}
  }
}

function listFilesInFolder(folderPath) {
  if (!existsSync(folderPath)) {
    return []
  }

  return readdirSync(folderPath)
    .map((name) => path.join(folderPath, name))
    .filter((filePath) => statSync(filePath).isFile())
}

function collectFilesRecursively(folderPath) {
  if (!existsSync(folderPath)) {
    return []
  }

  const results = []
  const entries = readdirSync(folderPath).map((name) => path.join(folderPath, name))

  for (const entryPath of entries) {
    const stats = statSync(entryPath)
    if (stats.isDirectory()) {
      const folderName = path.basename(entryPath).toLowerCase()
      if (skippedFolderNames.has(folderName)) {
        continue
      }

      results.push(...collectFilesRecursively(entryPath))
      continue
    }

    if (stats.isFile()) {
      results.push(entryPath)
    }
  }

  return results
}

function mediaPathFromAbsolute(filePath) {
  const relative = path.relative(path.join(projectRoot, 'public'), filePath)
  return '/' + toPosixPath(relative)
}

function fileNameWithoutExtension(filePath) {
  return path.basename(filePath, path.extname(filePath))
}

function folderPriorityForFile(filePath, projectFolderPath) {
  const relativeDir = path.dirname(path.relative(projectFolderPath, filePath))
  const normalizedSegments = toPosixPath(relativeDir)
    .split('/')
    .map((segment) => segment.toLowerCase())
    .filter(Boolean)

  if (normalizedSegments.some((segment) => finalPriorityFolderNames.has(segment))) {
    return 0
  }

  if (normalizedSegments.some((segment) => processPriorityFolderNames.has(segment))) {
    return 1
  }

  return 2
}

function compareMediaFiles(left, right, projectFolderPath) {
  const leftPriority = folderPriorityForFile(left, projectFolderPath)
  const rightPriority = folderPriorityForFile(right, projectFolderPath)

  if (leftPriority !== rightPriority) {
    return leftPriority - rightPriority
  }

  const leftRelativePath = toPosixPath(path.relative(projectFolderPath, left)).toLowerCase()
  const rightRelativePath = toPosixPath(path.relative(projectFolderPath, right)).toLowerCase()
  return leftRelativePath.localeCompare(rightRelativePath)
}

function shouldApplyMonochrome(filePath, projectFolderPath) {
  return folderPriorityForFile(filePath, projectFolderPath) === 1
}

function isHeicOrHeif(filePath) {
  return heicExtensions.has(path.extname(filePath).toLowerCase())
}

function convertedImagePath(filePath, projectFolderPath) {
  const relativePath = path.relative(projectFolderPath, filePath)
  const relativeDir = path.dirname(relativePath)
  const fileBaseName = fileNameWithoutExtension(filePath)

  return path.join(projectFolderPath, '.generated', relativeDir, `${fileBaseName}.jpg`)
}

async function ensureDisplayableImage(filePath, projectFolderPath) {
  if (!isHeicOrHeif(filePath)) {
    return filePath
  }

  const outputPath = convertedImagePath(filePath, projectFolderPath)
  const sourceStats = statSync(filePath)

  if (existsSync(outputPath)) {
    const outputStats = statSync(outputPath)
    if (outputStats.mtimeMs >= sourceStats.mtimeMs) {
      return outputPath
    }
  }

  mkdirSync(path.dirname(outputPath), { recursive: true })

  try {
    await sharp(filePath)
      .rotate()
      .jpeg({ quality: 92, mozjpeg: true })
      .withMetadata()
      .toFile(outputPath)
  } catch {
    const inputBuffer = readFileSync(filePath)
    const outputBuffer = await heicConvert({
      buffer: inputBuffer,
      format: 'JPEG',
      quality: 0.92,
    })
    writeFileSync(outputPath, outputBuffer)
  }

  try {
    await exiftool.write(
      outputPath,
      {},
      {
        writeArgs: [
          `-TagsFromFile=${filePath}`,
          '-EXIF:all',
          '-XMP:all',
          '-IPTC:all',
          '-overwrite_original',
        ],
      },
    )
  } catch (error) {
    console.warn(`Could not copy metadata from ${path.basename(filePath)}: ${error instanceof Error ? error.message : String(error)}`)
  }

  return outputPath
}

async function extractMetadata(filePath) {
  try {
    const tags = await exiftool.read(filePath)
    
    // Extract capture date (try multiple fields)
    const captureDate = tags.DateTimeOriginal || tags.CreateDate || tags.ModifyDate || tags.FileModifyDate
    
    // Extract GPS location with comprehensive field search
    let location = null
    
    // Try to get human-readable location first (City/Country/Region)
    const city = tags.City || tags.LocationCreatedCity || tags.LocationShownCity || tags.LocationName
    const country = tags.Country || tags.CountryName || tags.LocationCreatedCountryName || tags.CountryCode
    const state = tags.State || tags.Province || tags.Region
    const subloc = tags.SubLocation || tags.Location
    
    if (city || country || state || subloc) {
      // Build location string from available parts
      const parts = [subloc, city, state, country].filter(Boolean)
      location = parts.join(', ')
    } else if (tags.GPSLatitude && tags.GPSLongitude) {
      // Fall back to GPS coordinates only if no city-level data
      location = `${tags.GPSLatitude.toFixed(4)}, ${tags.GPSLongitude.toFixed(4)}`
    }
    
    return {
      captureDate: captureDate ? new Date(captureDate) : null,
      location,
    }
  } catch (error) {
    // Silently handle errors to avoid console clutter
    return { captureDate: null, location: null }
  }
}

function isAutoGeneratedFilename(filename, fileType) {
  const lower = filename.toLowerCase()
  
  // Screen recording patterns: Screenshot YYYY-MM-DD, Screen Shot, Screen Recording, screenshot_*, etc.
  if (/^screen[-_ ]?(shot|recording)/i.test(lower)) {
    return 'recording'
  }
  
  // WhatsApp patterns: IMG-YYYYMMDD-WAnnnn, VID-YYYYMMDD-WAnnnn, WhatsApp Image, WhatsApp Video, etc.
  if (/^(img|vid)[-_]\d{8}[-_]wa\d+/i.test(lower) || /^whatsapp\s+(image|video)/i.test(lower)) {
    return 'whatsapp'
  }
  
  // Recording patterns (non-screen): Recording YYYY-MM-DD, etc.
  if (/^recording\s+\d{4}/i.test(lower)) {
    return 'archive'
  }
  
  // Generic camera patterns: IMG_, DSC_, VID_, MOV_, 100_nnnn, Recording_nnnn, etc.
  if (/^(img|dsc|vid|mov|pano|recording|\d+)[-_]\d+/i.test(lower)) {
    return 'archive'
  }
  
  // Generic unnamed video patterns
  if (fileType === 'video' && (/^(video|movie|clip|untitled)/i.test(lower) || /^\d+$/.test(lower))) {
    return 'video'
  }
  
  // Generic unnamed model patterns
  if (fileType === 'model' && (/^(model|untitled|object|mesh)/i.test(lower) || /^\d+$/.test(lower))) {
    return 'model'
  }
  
  return null
}

async function createImageItem(sourceFilePath, displayFilePath, index, projectFolderPath, counters, metadata) {
  const rawFilename = fileNameWithoutExtension(sourceFilePath)
  const autoType = isAutoGeneratedFilename(rawFilename, 'image')
  
  let title
  if (autoType === 'recording') {
    counters.recording = (counters.recording || 0) + 1
    title = `rec_${counters.recording}`
  } else if (autoType === 'whatsapp') {
    counters.whatsapp = (counters.whatsapp || 0) + 1
    title = `chat_${counters.whatsapp}`
  } else if (autoType === 'archive') {
    counters.archive = (counters.archive || 0) + 1
    title = `archive_${counters.archive}`
  } else {
    title = rawFilename || `image_${index + 1}`
  }
  
  // Generate thumbnail from the image file
  let thumbnail = ''
  try {
    const imageBuffer = readFileSync(displayFilePath)
    thumbnail = await generateThumbnailDataUrl(imageBuffer)
  } catch (error) {
    // Silently fail thumbnail generation
  }
  
  return {
    title,
    location: metadata.location || null,
    captureDate: metadata.captureDate,
    src: mediaPathFromAbsolute(displayFilePath),
    thumbnail: thumbnail || undefined,
    monochrome: shouldApplyMonochrome(sourceFilePath, projectFolderPath),
  }
}

function createVideoItem(filePath, index, projectFolderPath, counters, metadata, sharedThumbnail) {
  const rawFilename = fileNameWithoutExtension(filePath)
  const autoType = isAutoGeneratedFilename(rawFilename, 'video')
  
  let title
  if (autoType === 'recording') {
    counters.recording = (counters.recording || 0) + 1
    title = `rec_${counters.recording}`
  } else if (autoType === 'whatsapp') {
    counters.whatsapp = (counters.whatsapp || 0) + 1
    title = `chat_${counters.whatsapp}`
  } else if (autoType === 'archive') {
    counters.archive = (counters.archive || 0) + 1
    title = `archive_${counters.archive}`
  } else if (autoType === 'video') {
    counters.video = (counters.video || 0) + 1
    title = `video_${counters.video}`
  } else {
    title = rawFilename || `video_${index + 1}`
  }
  
  return {
    title,
    location: metadata.location || null,
    captureDate: metadata.captureDate,
    src: mediaPathFromAbsolute(filePath),
    thumbnail: sharedThumbnail || undefined,
    monochrome: shouldApplyMonochrome(filePath, projectFolderPath),
  }
}

async function createModelItem(filePath, images, index, projectFolderPath, counters) {
  const rawFilename = fileNameWithoutExtension(filePath)
  const autoType = isAutoGeneratedFilename(rawFilename, 'model')
  
  let title
  if (autoType === 'recording') {
    counters.recording = (counters.recording || 0) + 1
    title = `rec_${counters.recording}`
  } else if (autoType === 'whatsapp') {
    counters.whatsapp = (counters.whatsapp || 0) + 1
    title = `chat_${counters.whatsapp}`
  } else if (autoType === 'archive') {
    counters.archive = (counters.archive || 0) + 1
    title = `archive_${counters.archive}`
  } else if (autoType === 'model') {
    counters.model = (counters.model || 0) + 1
    title = `model_${counters.model}`
  } else {
    title = rawFilename || `model_${index + 1}`
  }
  
  const previewImage = images[index] ?? images[0]
  return {
    title,
    location: null,
    previewSrc: previewImage ? previewImage.src : '',
    fileSrc: mediaPathFromAbsolute(filePath),
    monochrome: shouldApplyMonochrome(filePath, projectFolderPath),
  }
}

async function collectProjectMedia(projectFolderPath) {
  const allFiles = collectFilesRecursively(projectFolderPath).filter(
    (filePath) => path.basename(filePath).toLowerCase() !== 'project.json',
  )

  const imageFiles = allFiles
    .filter((filePath) => imageExtensions.has(path.extname(filePath).toLowerCase()))
    .sort((left, right) => compareMediaFiles(left, right, projectFolderPath))
  const videoFiles = allFiles
    .filter((filePath) => videoExtensions.has(path.extname(filePath).toLowerCase()))
    .sort((left, right) => compareMediaFiles(left, right, projectFolderPath))
  const modelFiles = allFiles
    .filter((filePath) => modelExtensions.has(path.extname(filePath).toLowerCase()))
    .sort((left, right) => compareMediaFiles(left, right, projectFolderPath))

  // Extract metadata for images and videos
  console.log(`Extracting metadata for ${imageFiles.length} images and ${videoFiles.length} videos...`)
  const imageMetadata = await Promise.all(imageFiles.map(extractMetadata))
  const videoMetadata = await Promise.all(videoFiles.map(extractMetadata))

  // Create items with metadata and capture date for sorting
  const imageItems = await Promise.all(
    imageFiles.map(async (filePath, index) => ({
      filePath,
      displayFilePath: await ensureDisplayableImage(filePath, projectFolderPath),
      metadata: imageMetadata[index],
      item: null,
    }))
  )
  const videoItems = await Promise.all(
    videoFiles.map(async (filePath, index) => ({
      filePath,
      metadata: videoMetadata[index],
      item: null,
    }))
  )

  // Sort by capture date (most recent first), fallback to file path
  const sortByDate = (a, b) => {
    if (a.metadata.captureDate && b.metadata.captureDate) {
      return b.metadata.captureDate - a.metadata.captureDate
    }
    if (a.metadata.captureDate) return -1
    if (b.metadata.captureDate) return 1
    return compareMediaFiles(a.filePath, b.filePath, projectFolderPath)
  }

  imageItems.sort(sortByDate)
  videoItems.sort(sortByDate)

  // Now generate final items with sequential numbering
  const counters = {}
  const images = await Promise.all(
    imageItems.map((item, index) =>
      createImageItem(item.filePath, item.displayFilePath, index, projectFolderPath, counters, item.metadata)
    )
  )
  
  // Get shared thumbnail for videos (reuse first image thumbnail)
  const sharedVideoThumbnail = images[0]?.thumbnail || ''
  
  const videos = videoItems.map((item, index) => 
    createVideoItem(item.filePath, index, projectFolderPath, counters, item.metadata, sharedVideoThumbnail)
  )
  const models = await Promise.all(
    modelFiles.map((filePath, index) => createModelItem(filePath, images, index, projectFolderPath, counters))
  )

  return { images, videos, models }
}

async function buildProjects() {
  if (shouldUseR2Source()) {
    if (!hasR2Credentials) {
      if (manifestSource === 'r2') {
        throw new Error(`R2_MANIFEST_SOURCE is set to "r2" but credentials are missing. Required env vars: ${requiredR2EnvVars.join(', ')}`)
      }
    } else {
      activeManifestSource = 'r2'
      console.log('Generating project manifest from R2 uploads...')
      return buildProjectsFromR2()
    }
  }

  activeManifestSource = 'local'
  console.log('Generating project manifest from local public/media/projects...')
  if (!existsSync(mediaProjectsRoot)) {
    if (existsSync(outputFile)) {
      console.warn(
        `Skipping media manifest generation: ${toPosixPath(path.relative(projectRoot, mediaProjectsRoot))} is missing. Keeping existing ${toPosixPath(path.relative(projectRoot, outputFile))}.`,
      )
      return null
    }

    mkdirSync(mediaProjectsRoot, { recursive: true })
  }

  const folderNames = readdirSync(mediaProjectsRoot)
    .map((name) => path.join(mediaProjectsRoot, name))
    .filter((folderPath) => statSync(folderPath).isDirectory())
    .map((folderPath) => path.basename(folderPath))

  if (folderNames.length === 0 && existsSync(outputFile)) {
    console.warn(
      `Skipping media manifest generation: no project folders found in ${toPosixPath(path.relative(projectRoot, mediaProjectsRoot))}. Keeping existing ${toPosixPath(path.relative(projectRoot, outputFile))}.`,
    )
    return null
  }

  const projects = await Promise.all(
    folderNames.map(async (slug) => {
      const folderPath = path.join(mediaProjectsRoot, slug)
      console.log(`Processing project: ${slug}`)
      const meta = safeReadProjectMeta(folderPath)
      const { images, videos, models } = await collectProjectMedia(folderPath)

      const thumbnailImage = images[0]
      const thumbnailVideo = videos[0]

      const thumbnailSrc =
        typeof meta.thumbnailSrc === 'string' && meta.thumbnailSrc.length > 0
          ? meta.thumbnailSrc
          : thumbnailVideo?.src ?? thumbnailImage?.src ?? ''

      const thumbnailMonochrome =
        typeof meta.thumbnailSrc === 'string' && meta.thumbnailSrc.length > 0
          ? shouldApplyMonochrome(path.join(projectRoot, 'public', meta.thumbnailSrc.replace(/^\//, '')), folderPath)
          : (thumbnailVideo?.monochrome ?? thumbnailImage?.monochrome ?? false)

      return {
        slug,
        title: typeof meta.title === 'string' && meta.title.length > 0 ? meta.title : slugToTitle(slug),
        categoryId: typeof meta.categoryId === 'string' ? meta.categoryId : 'renders',
        tagIds: Array.isArray(meta.tagIds) ? meta.tagIds.filter((value) => typeof value === 'string') : [],
        summary: typeof meta.summary === 'string' ? meta.summary : '',
        thumbnailSrc,
        thumbnailMonochrome,
        body: Array.isArray(meta.body) ? meta.body.filter((value) => typeof value === 'string') : [],
        images,
        videos,
        models,
      }
    })
  )

  return projects.filter((project) => project.thumbnailSrc || project.images.length || project.videos.length || project.models.length)
}

function writeOutput(projects) {
  const output = `export const generatedProjects = ${JSON.stringify(projects, null, 2)}\n`
  writeFileSync(outputFile, output, 'utf8')
}

async function main() {
  try {
    const projects = await buildProjects()
    if (projects === null) {
      return
    }

    writeOutput(projects)
    const sourceLabel = activeManifestSource === 'r2' ? 'R2 uploads' : 'local public/media/projects'
    console.log(`Generated ${projects.length} project(s) from ${sourceLabel}`)
  } finally {
    await exiftool.end()
  }
}

main().catch((error) => {
  console.error('Error:', error)
  process.exit(1)
})